{
  "hash": "3d9562b8532a9a5dffa8c3f74b67f183",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Predicting Pokemon Types with Pokedex Text Entries\"\ndate: 2025-09-15\ndescription: \"I've been looking for a way to work with Pokemon data for a while now, so I shoehorned topic modeling and natural language processing in there to finally justify it...\"\nimage: \"figures/pokeball.png\"\ntoc: true\nexecute:\n  warning: false\n  error: false\n  message: false\ntoc-location: \"left\"\ntoc-title: \"Contents\"\ncategories:\n  - nlp\n  - llm\n  - topic modeling\n  - machine learning\n  - pokemon\n---\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Load Libraries\npacman::p_load(\n  \"dplyr\", # Data Manipulation\n  \"readxl\", # Reading Excel Files\n  \"tidyr\", # Pivoting\n  \"ggplot2\", # Data Visualization\n  \"stringr\", # Working with Strings\n  \"purrr\", # Mapping\n  \"forcats\", # Factors\n  \"ggdist\", # Cool Distribution Plots\n  \"tibble\", # rownames_to_columns\n  \"stringr\", # Working with Texts\n  \"tidytext\", # NLP\n  \"quanteda\", # NLP\n  \"tm\", # NLP\n  \"SnowballC\", # NLP\n  \"caret\", # Machine Learning\n  \"stopwords\", # Stop Words\n  \"seededlda\", # Seeded LDA\n  \"tinytable\", # Tables\n  install = FALSE\n)\n\n# Define a Custom Theme\nblog_theme <- function() {\n  theme_bw() +  \n    theme(\n      panel.grid.major = element_line(color = \"gray80\", size = 0.3),\n      panel.grid.minor = element_blank(),\n      panel.border = element_blank(),\n      plot.background = element_rect(fill = \"white\", color = NA),\n      plot.title = element_text(face = \"bold\", size = 16, margin = margin(t = 0, r = 0, b = 15, l = 0)),\n      axis.title.x = element_text(face = \"bold\", size = 14, margin = margin(t = 15, r = 0, b = 0, l = 0)),\n      axis.title.y = element_text(face = \"bold\", size = 14, margin = margin(t = 0, r = 15, b = 0, l = 0)),\n      strip.text = element_text(face = \"bold\"),\n      axis.text.x = element_text(face = \"bold\", size = 10), \n      axis.text.y = element_text(face = \"bold\", size = 10), \n      axis.ticks.x = element_blank(), \n      axis.ticks.y = element_blank(), \n      strip.background = element_rect(fill = \"grey80\", color = NA),\n      legend.title = element_text(face = \"bold\", size = 14),\n      legend.text = element_text(face = \"bold\", size = 10, color = \"grey25\"),\n    )\n}\n\n# Establish a Custom Color Scheme\ncolors <- c(\n  \"#0a697d\",\n  \"#0091af\",\n  \"#ddb067\",\n  \"#c43d56\",\n  \"#ab2a42\"\n)\n\n# Establish a Pokemon Color Scheme\ntype_colors <- c(\n  normal = \"#A8A77A\",\n  fire = \"#EE8130\",\n  water = \"#6390F0\",\n  electric = \"#F7D02C\",\n  grass = \"#7AC74C\",\n  ice = \"#96D9D6\",\n  fighting = \"#C22E28\",\n  poison = \"#A33EA1\",\n  ground = \"#E2BF65\",\n  flying = \"#A98FF3\",\n  psychic = \"#F95587\",\n  bug = \"#A6B91A\",\n  rock = \"#B6A136\",\n  ghost = \"#735797\",\n  dragon = \"#6F35FC\",\n  dark = \"#705746\",\n  steel = \"#B7B7CE\",\n  fairy = \"#D685AD\"\n)\n\n# Establish a Custom Naming Scheme\ntype_names <- c(\n  grass = \"Grass\",\n  fire = \"Fire\",\n  water = \"Water\",\n  normal = \"Normal\",\n  electric = \"Electric\",\n  ice = \"Ice\",\n  fighting = \"Fighting\",\n  poison = \"Poison\",\n  ground = \"Ground\",\n  flying = \"Flying️\",\n  psychic = \"Psychic\",\n  bug = \"Bug\",\n  rock = \"Rock\",\n  ghost = \"Ghost\",\n  dragon = \"Dragon\",\n  dark = \"Dark\",\n  steel = \"Steel️\",\n  fairy = \"Fairy\"\n)\n\noptions(scipen = 999)\n```\n:::\n\n\n\nEven if you're not familiar with a lot of data science terminology, you've potentially heard of the term \"natural language processing\" (NLP). Most likely, you've probably heard of it within the context of AI/large language models (LLMs). Regardless, natural language processing really just refers to any statistical/machine learning/AI approach that seeks to uncover information and insights from human language. This can range from something as simple as a count of specific words in a document all the way to ChatGPT.\n\nSomewhere in the middle of that wide distribution is the field of topic modeling. Topic modeling is a sub-field of NLP that is applicable when a researcher has a large body of text (books, chapters, open-text survey responses, Word documents, emails, etc.) and wants to extract some of the themes/topics referenced in this body (a corpus) without manually reading every item in that corpus. There's a lot of different ways that you can do topic modeling, but typically when you mention it, the methodology of automatically extracting topics out of a corpus is driven by an algorithm developed for this very purpose (often, you will hear of something called [\"Latent Dirichlet Allocation\"](https://www.tidytextmining.com/topicmodeling#latent-dirichlet-allocation)).\n\nIn my line of work, I deal *a lot* with survey data. All of us have taken surveys, so you're probably familiar with the concept of an *open-text* survey question. For example, you could easily imagine something like \"please describe anything else related to X that was not covered in this survey\" and you're given a text box to fill in (if you so choose, a lot of people just leave it blank or fill in \"NA\" if they don't have anything to share/can't be bothered to write anything down).\n\nThese open-text survey questions are great in one sense because they don't force the respondents to match their answer to some set of discrete options the survey programmer designed. However, the difficult part is that it's really hard to process and make sense of *a lot* of open-text survey responses. With discrete responses, it's really easy since the response is converted to a numeric output. But how do you make sense of hundreds or thousands of open-text responses? You *could* manually code all of these responses but... have fun with that and let me know when you and your double checker coder are done at Christmas. Naturally, this scenario is a natural use-case for topic modeling. Consequently, I've used topic modeling algorithms a lot in my work for this very purpose.\n\nBut... is topic modeling the best way to handle problems like this anymore? Perhaps some of you have already thought, \"why not feed the open-text response into ChatGPT and let it tell you what it's about rather than having to learn these complex and, oftentimes, finicky topic modeling algorithms?\" Well, one reason you might not do this is for privacy concerns. People are probably responding to these open-text items with an expectation that it won't be fed into an LLM and, depending on who you are working for, you might have client restrictions that prevent you from feeding data into an LLM anyways. Another issue would be reproducibility. With a topic modeling algorithm, you can design the algorithm in such a way that the results are consistent and reproducible every time you run the same line of code. I'm not so sure you're going to get the same properties out of querying an LLM (to be fair, you probably wouldn't get the same results every time using human coders either).\n\nStill [Mellon et al. (2024)](https://journals.sagepub.com/doi/10.1177/20531680241231468) published an interesting study that compared the predictive accuracy of open-text survey topics when using human coders, LLMs, and topic models. A key takeaway is that *some* LLMs perform *almost* as well as human coders and often outperform topic modeling algorithms. I'm *really* interested in this because I've often seen firsthand the struggles that topic modeling algorithms can have. However, I have not been able to test out the LLM approach in my professional work for contract-related reasons. So, I decided to learn about this in a personal project... But what data set should I use?\n\nWell I thought about this and considered just going to a popular social science survey and giving that a try... but that is too close to what I do for work and so I wanted to do something fun instead. Which is pretty much why I am using a Pokemon data set that sort of mimics what you'll run into with an open-text survey response. In this blog, I'm going to be testing out a bunch of different ways to see if I can automatically classify a Pokemon's type based on its Pokedex entry. Pokedex entries are often fairly sparse, with only 1-2 sentences for each Pokemon. That doesn't sound like a lot (and it's not) but it resembles the reality of many open-text responses where survey respondents often answer in incomplete sentences or, if you're lucky, a handful of sentences. That's just a natural challenge with analyzing open-text survey data, so I wanted to re-create that with a more laid back substitute.\n\n# Introducing the Pokemon Data Set\n\nYou can find a lot of different Pokemon data sets online, but I needed to find one that had Pokedex entries. Ideally, I would have liked to have found a data set that contained *all* Pokedex entries (for those unfamiliar, each generation of Pokemon games creates a new Pokedex entry for the Pokemon from previous generations). But, I could not find anything like that. Plus, it sort of creates bias in the analysis since older Pokemon will have more entries, which basically translates to more data, so no matter what we use, we'd always see bias that predicts older Pokemon's types better than the types of newer Pokemon. So, I used [this data set](https://www.kaggle.com/datasets/rzgiza/pokdex-for-all-1025-pokemon-w-text-description/data) from Kaggle which contains Pokedex entries for all 1,025 Pokemon.\n\nIn the code chunk below, I am doing a couple of things to manipulate this data to be what I need it to be. For example, because some Pokemon have more than one type, I need to create another column that captures what type(s) Pokemon have. I do this by creating a dummy for each type (this will matter for making predictions later). Lastly, some Pokedex entries have the Pokemon's name in the entry... which feels a little like cheating. Fortunately, when this happens, the Pokemon's name is in full caps, so I use some regex to omit any string of text in a Pokemon's Pokedex entry if it contains the Pokemon's name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npokedex <- read.csv(\"data/pokedex.csv\")\n\npokedex <- pokedex |> \n  # Create Type Binary Columns\n  mutate(\n    type_grass = ifelse(str_detect(type, \"grass\"), 1, 0),\n    type_fire = ifelse(str_detect(type, \"fire\"), 1, 0),\n    type_water = ifelse(str_detect(type, \"water\"), 1, 0),\n    type_normal = ifelse(str_detect(type, \"normal\"), 1, 0),\n    type_electric = ifelse(str_detect(type, \"electric\"), 1, 0),\n    type_ice = ifelse(str_detect(type, \"ice\"), 1, 0),\n    type_fighting = ifelse(str_detect(type, \"fighting\"), 1, 0),\n    type_poison = ifelse(str_detect(type, \"poison\"), 1, 0),\n    type_ground = ifelse(str_detect(type, \"ground\"), 1, 0),\n    type_flying = ifelse(str_detect(type, \"flying\"), 1, 0),\n    type_psychic = ifelse(str_detect(type, \"psychic\"), 1, 0),\n    type_bug = ifelse(str_detect(type, \"bug\"), 1, 0),\n    type_rock = ifelse(str_detect(type, \"rock\"), 1, 0),\n    type_ghost = ifelse(str_detect(type, \"ghost\"), 1, 0),\n    type_dragon = ifelse(str_detect(type, \"dragon\"), 1, 0),\n    type_dark = ifelse(str_detect(type, \"dark\"), 1, 0),\n    type_steel = ifelse(str_detect(type, \"steel\"), 1, 0),\n    type_fairy = ifelse(str_detect(type, \"fairy\"), 1, 0)\n  ) |> \n  # Clean \"info\" Column to Purge Identifying Information (Like the Pokemon's Name Which Is in All Caps In This Data Set)\n  mutate(info = str_remove_all(info, \"\\\\b[A-Z]{2,}\\\\b\"))\n```\n:::\n\n\n\nAnd just to make sure everything's right, I'm going to take a look at defense statistics for each type. And... it looks like everything checks out with the distribution of defense statistics being higher in the steel, rock, ground, and dragon types. (Ghost type at #5 though?? Interesting).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Create a Data Frame of Level 1, 2, and 3 Evolution\npokedex <- pokedex |> \n  group_by(evo_set) |> \n  mutate(\n    level1 = as.integer(row_number() == 1),\n    level2 = as.integer(row_number() == 2),\n    level3 = as.integer(row_number() == 3)\n  ) |> \n  ungroup()\n\n# Create a Long-Form Data Set for Typing\npokedex_long <- pokedex |> \n  pivot_longer(\n    cols = starts_with(\"type_\"),\n    names_to = \"type_name\",\n    values_to = \"has_type\"\n  ) |> \n  # This Omits Copies Where a Given Pokemon Does Not Belong to a Given Type\n  # For Dual-Typing, Two Copies Are Made for the Pokemon\n  filter(has_type == 1) |> \n  mutate(type_name = str_remove(type_name, \"type_\"))\n\n# Distribution Plot by Defense\nggplot(pokedex_long, aes(\n  x = defense,\n  y = fct_reorder(type_name, defense, .fun = mean),\n  fill = type_name\n  )) +\n  stat_halfeye(\n    adjust = 0.7,\n    point_interval = NULL\n  ) +\n  scale_y_discrete(labels = type_names) +  \n  scale_fill_manual(values = type_colors) + \n  blog_theme() +\n  labs(\n    title = \"\",\n    x = \"Defense\",\n    y = \"\"\n  ) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Distribution of Defense Stats Across Typing](index_files/figure-html/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n\n# Strategy\n\nPrior to getting into classification strategies, we need to clean up the text data. Below, I am just creating a basic text data cleaning function that does some of the basics like standardizing punctuation, setting all text to lower-case, removing stop words, etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Store Stop Words for Filtering\nstop_words_data <- stop_words$word\n\n# Create a Function to Clean Text\nclean_text <- function(text) {\n  text |>\n    # Set to Lowercase\n    str_to_lower() |> \n    # Remove Possessive \"'s\"\n    str_replace_all(\"'s\\\\b\", \"\") |>   \n    # Remove Plural Possessives\n    str_replace_all(\"\\\\bs'\\\\b\", \"\") |>   \n    # Remove Punctuation\n    str_replace_all(\"[^a-z\\\\s]\", \" \") |>  \n    # Remove Extra Space\n    str_squish() |>  \n    # Tokenize\n    str_split(\" \") |>                              \n    unlist() |>\n    # Remove Stop Words\n    discard(~ .x %in% stop_words_data) |>   \n    # Stem Worlds\n    wordStem(language = \"en\") |>   \n    # Combine Everything Back Into a String\n    str_c(collapse = \" \")                      \n}\n\ntidy_pokemon <- pokedex |>\n  mutate(info = map_chr(info, clean_text)) \n```\n:::\n\n\n\nNow, there's a lot of different ways that we can go about trying to use Pokedex entries to classify a Pokemon's type. The simplest method is string matching and the logic is very intuitive. Basically, for each type, we define a set of key words/terms that are assumed to be heavily associated with a given Pokemon type. Then, if the string response for a Pokedex entry contains a keyword for a given type, we predict that Pokemon as being of that given type. Super simple, but not perfect. If we define our key words too narrowly, we run the risk of a lot of false negatives. In contrast, if we are very liberal with our definition of key words, we run the risk of predicting a lot of false positives.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Establish Keywords for Each Type\ngrass_keys <- c(\"grass\", \"leaf\", \"tree\", \"plant\", \"seed\", \"bloom\", \"flower\", \"forest\", \"leav\", \"grow\", \"petal\", \"aroma\", \"fruit\", \"vine\", \"branch\", \"bud\", \"cotton\", \"appl\", \"root\")\nfire_keys <- c(\"fire\", \"hot\", \"flame\", \"burn\", \"ember\", \"heat\", \"fieri\", \"firebal\", \"fahrenheit\", \"magma\")\nwater_keys <- c(\"water\", \"shell\", \"swim\", \"ocean\", \"sea\", \"fin\", \"bubbl\", \"depth\")\nnormal_keys <- c(\"normal\", \"common\", \"fur\")\nelectric_keys <- c(\"electr\", \"light\", \"thunder\", \"lightn\", \"spark\", \"charg\", \"shock\")\nice_keys <- c(\"ice\", \"freez\", \"frozen\", \"snow\", \"ici\", \"cold\", \"snowi\", \"frigid\")\nfighting_keys <- c(\"fight\", \"punch\", \"kick\", \"martial\", \"muscl\", \"strong\", \"strength\", \"fist\")\npoison_keys <- c(\"poison\", \"venom\", \"sting\", \"toxic\", \"gas\", \"fluid\", \"acid\", \"spray\")\nground_keys <- c(\"ground\", \"underground\", \"earthquak\", \"mud\", \"sand\", \"dig\")\nflying_keys <- c(\"fli\", \"wing\", \"feather\", \"beak\", \"bird\", \"wind\", \"sky\", \"flap\", \"cloud\", \"air\")\npsychic_keys <- c(\"psychic\", \"brain\", \"space\", \"control\", \"dream\", \"futur\", \"intellig\")\nbug_keys <- c(\"bug\", \"silk\", \"stinger\", \"insect\", \"honey\", \"pollen\", \"shell\")\nrock_keys <- c(\"rock\", \"hard\", \"fossil\", \"ancient\", \"stone\", \"boulder\", \"coal\")\nghost_keys <- c(\"ghost\", \"spirit\", \"curs\", \"soul\", \"possess\")\ndragon_keys <- c(\"dragon\", \"scale\", \"power\", \"wing\", \"tusk\")\ndark_keys <- c(\"dark\", \"night\", \"fear\")\nsteel_keys <- c(\"steel\", \"magnet\", \"iron\", \"metal\", \"armor\", \"hammer\")\nfairy_keys <- c(\"light\", \"fairi\")\n\n# Create a List of Types\ntypes <- c(\n  \"grass\", \"fire\", \"water\", \"normal\", \"electric\", \"ice\",\n  \"fighting\", \"poison\", \"ground\", \"flying\", \"psychic\", \"bug\",\n  \"rock\", \"ghost\", \"dragon\", \"dark\", \"steel\", \"fairy\"\n)\n\n# Make Predictions Based on String Matching\nsm_preds <- tidy_pokemon |> \n  mutate(\n    method = \"string_matching\",\n    grass_match = if_else(str_detect(info, str_c(grass_keys, collapse = \"|\")), 1, 0),\n    fire_match = if_else(str_detect(info, str_c(fire_keys, collapse = \"|\")), 1, 0),\n    water_match = if_else(str_detect(info, str_c(water_keys, collapse = \"|\")), 1, 0),\n    normal_match = if_else(str_detect(info, str_c(normal_keys, collapse = \"|\")), 1, 0),\n    electric_match = if_else(str_detect(info, str_c(electric_keys, collapse = \"|\")), 1, 0),\n    ice_match = if_else(str_detect(info, str_c(ice_keys, collapse = \"|\")), 1, 0),\n    fighting_match = if_else(str_detect(info, str_c(fighting_keys, collapse = \"|\")), 1, 0),\n    poison_match = if_else(str_detect(info, str_c(poison_keys, collapse = \"|\")), 1, 0),\n    ground_match = if_else(str_detect(info, str_c(ground_keys, collapse = \"|\")), 1, 0),\n    flying_match = if_else(str_detect(info, str_c(flying_keys, collapse = \"|\")), 1, 0),\n    psychic_match = if_else(str_detect(info, str_c(psychic_keys, collapse = \"|\")), 1, 0),\n    bug_match = if_else(str_detect(info, str_c(bug_keys, collapse = \"|\")), 1, 0),\n    rock_match = if_else(str_detect(info, str_c(rock_keys, collapse = \"|\")), 1, 0),\n    ghost_match = if_else(str_detect(info, str_c(ghost_keys, collapse = \"|\")), 1, 0),\n    dragon_match = if_else(str_detect(info, str_c(dragon_keys, collapse = \"|\")), 1, 0),\n    dark_match = if_else(str_detect(info, str_c(dark_keys, collapse = \"|\")), 1, 0),\n    steel_match = if_else(str_detect(info, str_c(steel_keys, collapse = \"|\")), 1, 0),\n    fairy_match = if_else(str_detect(info, str_c(fairy_keys, collapse = \"|\")), 1, 0)\n  )\n\n# Create an Empty Data Frame to Store Results\nstring_matching_metrics <- data.frame()\n\n# Loop Through Each Type for Predictive Metrics\nfor (type in types) {\n  \n  match_col <- paste0(type, \"_match\")\n  true_col <- paste0(\"type_\", type)\n  \n  true <- factor(ifelse(sm_preds[[true_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  predicted <- factor(ifelse(sm_preds[[match_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(predicted, true, positive = \"yes\")\n  \n  # Store Metrics\n  string_matching_metrics <- bind_rows(string_matching_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"string_matching\"\n  ))\n}\n```\n:::\n\n\n\nBut perhaps if we use a bit more of a complicated method, it will be able to navigate the nuances of the data to navigate this tricky balance. To investigate this, I am using a topic modeling algorithm known as seeded Latent Dirichlet Allocation (SLDA), developed by [Watanabe and Baturo (2024)](https://journals.sagepub.com/doi/10.1177/08944393231178605). To understand how this works, consider the basic Latent Dirichlet Allocation (LDA) model, a *very* popular, if not limited, topic modeling approach. LDA assumes that each text entry in a corpus of documents represents some mixture of topics. For example, if we have topics A, B, C, and D, then the contents of Document X could be 20% from Topic A, 50% from Topic B, 25% from Topic C, and 5% from Topic D. Furthermore, each topic itself is a mixture of words. If we are looking at a cooking manual and Topic A is \"Baking\" then some of the words that might contribute to Topic A might be \"baking\", \"oven\", \"cookies\", \"pre-heat\", etc. But, there's a noticeable problem with LDA.\n\nWhen executing LDA, the user simply tells the algorithm how many topics to look for ($k$ = 4? 8? 100?). There is no *right* answer for how many topics there truly are, so there's some educated guesswork to this. This itself is not a fundamental problem for LDA, but the *actual* core issue is that standard LDA has no way of telling the user what each topic is. Topic 1 is simply Topic 1 and it's up to the user to figure out what that topic is actually about. Further, if a corpus truly only consists of 4 topics, but you tell the LDA algorithm to search for 10, it will sure enough find 10, even though 10 topics do not exist, so have fun interpreting your results and making sense of the topics it spits back out at you.\n\nA lot of researchers in NLP have extended the LDA algorithm, either by enhancing the model directly or developing entirely different topics models. For this blog, I will be working with seeded LDA which really helps to overcome the problem of the algorithm being agnostic on the *types* of topics in the corpus. This is very useful when you already know *what* the topics are in a corpus, you just don't know which topics each and every document in the corpus belongs to. And the `{seededlda}` R package makes this all very simple. Much like string matching, you can just supply key words/terms to the algorithm to define both the number of topics that the algorithm will look for, but also to strongly inform what those topics are. For example, I am telling the algorithm that \"grass\" is a topic and the following words (\"grass\", \"leaf\", \"tree\", \"plant\", \"seed\", \"bloom\", \"flower\", \"forest\") are key components to that topic. With these \"seeds\" supplied for each type, I will get$\\theta$ (theta) values back, which tell me the predicted topic distribution for each Pokemon.\n\nBut what are you actually supposed to *do* with these $\\theta$ values? I don't think there's anything tried and true (please correct me if I'm wrong), so I'm going to look at a lot of different things. A simple approach is to develop a simple classification rule using the $\\theta$ values. For example, let's say we've ran our SLDA algorithm and get $\\theta$ values for each type of Bulbasaur. Let's say they look something like this for the highest 5 $\\theta$ values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmock_slda <- data.frame(\n  `Type (Topic)` = c(\"Grass\", \"Poison\", \"Bug\", \"Fairy\", \"Normal\"),\n  `Theta` = c(0.46, 0.29, 0.07, 0.02, 0.001),\n  check.names = FALSE\n)\n\ntt(mock_slda) |>\n  style_tt(align = \"c\")                    \n```\n\n::: {.cell-output-display}\n\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_ovg4s4lvb1r8hvpcjvxf(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_ovg4s4lvb1r8hvpcjvxf\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_ovg4s4lvb1r8hvpcjvxf');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_ovg4s4lvb1r8hvpcjvxf(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_ovg4s4lvb1r8hvpcjvxf\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 5, j: 0 }, { i: 5, j: 1 },  ], css_id: 'tinytable_css_0fl54m2gmgyte9y0ktb2',}, \n          { positions: [ { i: 1, j: 0 }, { i: 3, j: 0 }, { i: 4, j: 0 }, { i: 3, j: 1 }, { i: 2, j: 0 }, { i: 1, j: 1 }, { i: 2, j: 1 }, { i: 4, j: 1 },  ], css_id: 'tinytable_css_7jihvvjijfyg6bbrtekk',}, \n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 },  ], css_id: 'tinytable_css_mmgjezi2almimtzjxeh1',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_ovg4s4lvb1r8hvpcjvxf(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_0fl54m2gmgyte9y0ktb2, .table th.tinytable_css_0fl54m2gmgyte9y0ktb2 { text-align: center; border-bottom: solid #d3d8dc 0.1em; }\n      .table td.tinytable_css_7jihvvjijfyg6bbrtekk, .table th.tinytable_css_7jihvvjijfyg6bbrtekk { text-align: center; }\n      .table td.tinytable_css_mmgjezi2almimtzjxeh1, .table th.tinytable_css_mmgjezi2almimtzjxeh1 { text-align: center; border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_ovg4s4lvb1r8hvpcjvxf\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">Type (Topic)</th>\n                <th scope=\"col\">Theta</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>Grass</td>\n                  <td>0.460</td>\n                </tr>\n                <tr>\n                  <td>Poison</td>\n                  <td>0.290</td>\n                </tr>\n                <tr>\n                  <td>Bug</td>\n                  <td>0.070</td>\n                </tr>\n                <tr>\n                  <td>Fairy</td>\n                  <td>0.020</td>\n                </tr>\n                <tr>\n                  <td>Normal</td>\n                  <td>0.001</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n\n:::\n:::\n\n\n\nSince we know Pokemon, these mock results make sense. These results tell us that 75% of Bulbasaur's Pokedex entry comes from either the grass or the poison type. But how do we make predictions based on this? One idea is to just define an arbitrary classification rule using the theta value. For example, we could say that, for a each type, if $\\theta$ \\>= 0.5, then we assign it to that type. But, such a rule is very punitive when the algorithm is uncertain and spreads $\\theta$ across a lot of types. Further, for dual types, it is systematically biased since the distribution *should* be more evenly split. A way around this is to just lower the cut-off, i.e. $\\theta$ \\>= 0.4, $\\theta$ \\>= 0.3, etc. So, that's what I do. I'll be evaluating one strategy by using SLDA $\\theta$ values and assign three very simple classification rules.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\n# Tokenize the Data for SLDA\ntokens <- tidy_pokemon |> \n  unnest_tokens(word, info) \n\n# Cast a DFM\ndfm <- tokens |> \n  count(id, word) |> \n  cast_dfm(id, word, n)\n\n# Define Seeds\nlda_seeds <- quanteda::dictionary(list(\n  grass = grass_keys,\n  fire = fire_keys,\n  water = water_keys,\n  normal = normal_keys,\n  electric = electric_keys,\n  ice = ice_keys,\n  fighting = fighting_keys,\n  poison = poison_keys,\n  ground = ground_keys,\n  flying = flying_keys,\n  psychic = psychic_keys,\n  bug = bug_keys,\n  rock = rock_keys,\n  ghost = ghost_keys,\n  dragon = dragon_keys,\n  dark = dark_keys,\n  steel = steel_keys,\n  fairy = fairy_keys\n))\n\nseeded_lda <- textmodel_seededlda(dfm, lda_seeds)\n\n# Extract Thetas from SLDA\nslda_theta <- seeded_lda$theta |> \n  as.data.frame() |> \n  rownames_to_column(var = \"id\") |> \n  mutate(id = as.integer(id)) |> \n  left_join(tidy_pokemon, by = \"id\")\n\n# Make Predictions with SLDA 30% Rule\nslda30_preds <- slda_theta |> \n  mutate(\n    method = \"SLDA_30%\",\n    grass_match_slda_30 = if_else(str_detect(info, str_c(grass_keys, collapse = \"|\")) | grass >= 0.3, 1, 0),\n    fire_match_slda_30 = if_else(str_detect(info, str_c(fire_keys, collapse = \"|\")) | fire >= 0.3, 1, 0),\n    water_match_slda_30 = if_else(str_detect(info, str_c(water_keys, collapse = \"|\")) | water >= 0.3, 1, 0),\n    normal_match_slda_30 = if_else(str_detect(info, str_c(normal_keys, collapse = \"|\")) | normal >= 0.3, 1, 0),\n    electric_match_slda_30 = if_else(str_detect(info, str_c(electric_keys, collapse = \"|\")) | electric >= 0.3, 1, 0),\n    ice_match_slda_30 = if_else(str_detect(info, str_c(ice_keys, collapse = \"|\")) | ice >= 0.3, 1, 0),\n    fighting_match_slda_30 = if_else(str_detect(info, str_c(fighting_keys, collapse = \"|\")) | fighting >= 0.3, 1, 0),\n    poison_match_slda_30 = if_else(str_detect(info, str_c(poison_keys, collapse = \"|\")) | poison >= 0.3, 1, 0),\n    ground_match_slda_30 = if_else(str_detect(info, str_c(ground_keys, collapse = \"|\")) | ground >= 0.3, 1, 0),\n    flying_match_slda_30 = if_else(str_detect(info, str_c(flying_keys, collapse = \"|\")) | flying >= 0.3, 1, 0),\n    psychic_match_slda_30 = if_else(str_detect(info, str_c(psychic_keys, collapse = \"|\")) | psychic >= 0.3, 1, 0),\n    bug_match_slda_30 = if_else(str_detect(info, str_c(bug_keys, collapse = \"|\")) | bug >= 0.3, 1, 0),\n    rock_match_slda_30 = if_else(str_detect(info, str_c(rock_keys, collapse = \"|\")) | rock >= 0.3, 1, 0),\n    ghost_match_slda_30 = if_else(str_detect(info, str_c(ghost_keys, collapse = \"|\")) | ghost >= 0.3, 1, 0),\n    dragon_match_slda_30 = if_else(str_detect(info, str_c(dragon_keys, collapse = \"|\")) | dragon >= 0.3, 1, 0),\n    dark_match_slda_30 = if_else(str_detect(info, str_c(dark_keys, collapse = \"|\")) | dark >= 0.3, 1, 0),\n    steel_match_slda_30 = if_else(str_detect(info, str_c(steel_keys, collapse = \"|\")) | steel >= 0.3, 1, 0),\n    fairy_match_slda_30 = if_else(str_detect(info, str_c(fairy_keys, collapse = \"|\")) | fairy >= 0.3, 1, 0)\n  )\n\n# Create an Empty Data Frame to Store Results\ntheta_30_sm_metrics <- data.frame()\n\n# Loop Through Each Type for Predictive Metrics\nfor (type in types) {\n  \n  match_col <- paste0(type, \"_match_slda_30\")\n  true_col <- paste0(\"type_\", type)\n  \n  true <- factor(ifelse(slda30_preds[[true_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  predicted <- factor(ifelse(slda30_preds[[match_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(predicted, true, positive = \"yes\")\n  \n  # Store Metrics\n  theta_30_sm_metrics <- bind_rows(theta_30_sm_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"SLDA_30\"\n  ))\n}\n\n# Make Predictions with SLDA 40% Rule\nslda40_preds <- slda_theta |> \n  mutate(\n    method = \"SLDA_40%\",\n    grass_match_slda_40 = if_else(str_detect(info, str_c(grass_keys, collapse = \"|\")) | grass >= 0.4, 1, 0),\n    fire_match_slda_40 = if_else(str_detect(info, str_c(fire_keys, collapse = \"|\")) | fire >= 0.4, 1, 0),\n    water_match_slda_40 = if_else(str_detect(info, str_c(water_keys, collapse = \"|\")) | water >= 0.4, 1, 0),\n    normal_match_slda_40 = if_else(str_detect(info, str_c(normal_keys, collapse = \"|\")) | normal >= 0.4, 1, 0),\n    electric_match_slda_40 = if_else(str_detect(info, str_c(electric_keys, collapse = \"|\")) | electric >= 0.4, 1, 0),\n    ice_match_slda_40 = if_else(str_detect(info, str_c(ice_keys, collapse = \"|\")) | ice >= 0.4, 1, 0),\n    fighting_match_slda_40 = if_else(str_detect(info, str_c(fighting_keys, collapse = \"|\")) | fighting >= 0.4, 1, 0),\n    poison_match_slda_40 = if_else(str_detect(info, str_c(poison_keys, collapse = \"|\")) | poison >= 0.4, 1, 0),\n    ground_match_slda_40 = if_else(str_detect(info, str_c(ground_keys, collapse = \"|\")) | ground >= 0.4, 1, 0),\n    flying_match_slda_40 = if_else(str_detect(info, str_c(flying_keys, collapse = \"|\")) | flying >= 0.4, 1, 0),\n    psychic_match_slda_40 = if_else(str_detect(info, str_c(psychic_keys, collapse = \"|\")) | psychic >= 0.4, 1, 0),\n    bug_match_slda_40 = if_else(str_detect(info, str_c(bug_keys, collapse = \"|\")) | bug >= 0.4, 1, 0),\n    rock_match_slda_40 = if_else(str_detect(info, str_c(rock_keys, collapse = \"|\")) | rock >= 0.4, 1, 0),\n    ghost_match_slda_40 = if_else(str_detect(info, str_c(ghost_keys, collapse = \"|\")) | ghost >= 0.4, 1, 0),\n    dragon_match_slda_40 = if_else(str_detect(info, str_c(dragon_keys, collapse = \"|\")) | dragon >= 0.4, 1, 0),\n    dark_match_slda_40 = if_else(str_detect(info, str_c(dark_keys, collapse = \"|\")) | dark >= 0.4, 1, 0),\n    steel_match_slda_40 = if_else(str_detect(info, str_c(steel_keys, collapse = \"|\")) | steel >= 0.4, 1, 0),\n    fairy_match_slda_40 = if_else(str_detect(info, str_c(fairy_keys, collapse = \"|\")) | fairy >= 0.4, 1, 0)\n  )\n\n# Create an Empty Data Frame to Store Results\ntheta_40_sm_metrics <- data.frame()\n\n# Loop Through Each Type for Predictive Metrics\nfor (type in types) {\n  \n  match_col <- paste0(type, \"_match_slda_40\")\n  true_col <- paste0(\"type_\", type)\n  \n  true <- factor(ifelse(slda40_preds[[true_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  predicted <- factor(ifelse(slda40_preds[[match_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(predicted, true, positive = \"yes\")\n  \n  # Store Metrics\n  theta_40_sm_metrics <- bind_rows(theta_40_sm_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"SLDA_40\"\n  ))\n}\n\n# Make Predictions with SLDA 50% Rule\nslda50_preds <- slda_theta |> \n  mutate(\n    method = \"SLDA_50%\",\n    grass_match_slda_50 = if_else(str_detect(info, str_c(grass_keys, collapse = \"|\")) | grass >= 0.5, 1, 0),\n    fire_match_slda_50 = if_else(str_detect(info, str_c(fire_keys, collapse = \"|\")) | fire >= 0.5, 1, 0),\n    water_match_slda_50 = if_else(str_detect(info, str_c(water_keys, collapse = \"|\")) | water >= 0.5, 1, 0),\n    normal_match_slda_50 = if_else(str_detect(info, str_c(normal_keys, collapse = \"|\")) | normal >= 0.5, 1, 0),\n    electric_match_slda_50 = if_else(str_detect(info, str_c(electric_keys, collapse = \"|\")) | electric >= 0.5, 1, 0),\n    ice_match_slda_50 = if_else(str_detect(info, str_c(ice_keys, collapse = \"|\")) | ice >= 0.5, 1, 0),\n    fighting_match_slda_50 = if_else(str_detect(info, str_c(fighting_keys, collapse = \"|\")) | fighting >= 0.5, 1, 0),\n    poison_match_slda_50 = if_else(str_detect(info, str_c(poison_keys, collapse = \"|\")) | poison >= 0.5, 1, 0),\n    ground_match_slda_50 = if_else(str_detect(info, str_c(ground_keys, collapse = \"|\")) | ground >= 0.5, 1, 0),\n    flying_match_slda_50 = if_else(str_detect(info, str_c(flying_keys, collapse = \"|\")) | flying >= 0.5, 1, 0),\n    psychic_match_slda_50 = if_else(str_detect(info, str_c(psychic_keys, collapse = \"|\")) | psychic >= 0.5, 1, 0),\n    bug_match_slda_50 = if_else(str_detect(info, str_c(bug_keys, collapse = \"|\")) | bug >= 0.5, 1, 0),\n    rock_match_slda_50 = if_else(str_detect(info, str_c(rock_keys, collapse = \"|\")) | rock >= 0.5, 1, 0),\n    ghost_match_slda_50 = if_else(str_detect(info, str_c(ghost_keys, collapse = \"|\")) | ghost >= 0.5, 1, 0),\n    dragon_match_slda_50 = if_else(str_detect(info, str_c(dragon_keys, collapse = \"|\")) | dragon >= 0.5, 1, 0),\n    dark_match_slda_50 = if_else(str_detect(info, str_c(dark_keys, collapse = \"|\")) | dark >= 0.5, 1, 0),\n    steel_match_slda_50 = if_else(str_detect(info, str_c(steel_keys, collapse = \"|\")) | steel >= 0.5, 1, 0),\n    fairy_match_slda_50 = if_else(str_detect(info, str_c(fairy_keys, collapse = \"|\")) | fairy >= 0.5, 1, 0)\n  )\n\n# Create an Empty Data Frame to Store Results\ntheta_50_sm_metrics <- data.frame()\n\n# Loop Through Each Type for Predictive Metrics\nfor (type in types) {\n  \n  match_col <- paste0(type, \"_match_slda_50\")\n  true_col <- paste0(\"type_\", type)\n  \n  true <- factor(ifelse(slda50_preds[[true_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  predicted <- factor(ifelse(slda50_preds[[match_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(predicted, true, positive = \"yes\")\n  \n  # Store Metrics\n  theta_50_sm_metrics <- bind_rows(theta_50_sm_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"SLDA_50\"\n  ))\n}\n```\n:::\n\n\n\nAlternatively, we could just plug the $\\theta$ values into a machine learning algorithm and hope that it can pick up on some added nuance in assigning classifications, so we'll give that a try as well.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Establish the Cross Validation Parameters\ncv <- trainControl(\n  method = \"cv\",\n  number = 5,\n  classProbs = TRUE,\n  summaryFunction = twoClassSummary,\n  savePredictions = TRUE,\n  sampling = \"smote\"\n)\n\ntype_cols <- paste0(\"type_\", c(\n  \"normal\", \"fire\", \"water\", \"grass\", \"electric\", \"ice\", \"fighting\",\n  \"poison\", \"ground\", \"flying\", \"psychic\", \"bug\", \"rock\",\n  \"ghost\", \"dragon\", \"dark\", \"steel\", \"fairy\"\n))\n\n# Pre Learning Cleaning\nslda_theta <- slda_theta |> \n  # Convert All Outcomes to Factors\n  mutate(across(all_of(type_cols), ~ factor(ifelse(. == 1, \"yes\", \"no\"), levels = c(\"no\", \"yes\"))))\n\n# Train Each Model\ngrass_model_thetas <- train(type_grass ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfire_model_thetas <- train(type_fire ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nwater_model_thetas <- train(type_water ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nnormal_model_thetas <- train(type_normal ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nelectric_model_thetas <- train(type_electric ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nice_model_thetas <- train(type_ice ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfighting_model_thetas <- train(type_fighting ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npoison_model_thetas <- train(type_poison ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nground_model_thetas <- train(type_ground ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nflying_model_thetas <- train(type_flying ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npsychic_model_thetas <- train(type_psychic ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nbug_model_thetas <- train(type_bug ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nrock_model_thetas <- train(type_rock ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nghost_model_thetas <- train(type_ghost ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndragon_model_thetas <- train(type_dragon ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndark_model_thetas <- train(type_dark ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nsteel_model_thetas <- train(type_steel ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfairy_model_thetas <- train(type_fairy ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\n\n# Store Models in a List\nmodel_list_thetas <- list(\n  grass = grass_model_thetas,\n  fire = fire_model_thetas,\n  water = water_model_thetas,\n  normal = normal_model_thetas,\n  electric = electric_model_thetas,\n  ice = ice_model_thetas,\n  fighting = fighting_model_thetas,\n  poison = poison_model_thetas,\n  ground = ground_model_thetas,\n  flying = flying_model_thetas,\n  psychic = psychic_model_thetas,\n  bug = bug_model_thetas,\n  rock = rock_model_thetas,\n  ghost = ghost_model_thetas,\n  dragon = dragon_model_thetas,\n  dark = dark_model_thetas,\n  steel = steel_model_thetas,\n  fairy = fairy_model_thetas\n)\n\n# Create an Empty Data Frame to Store Results\ntheta_model_metrics <- data.frame()\n\n# Loop Through Each Model\nfor (type in names(model_list_thetas)) {\n  \n  model <- model_list_thetas[[type]]\n  \n  # Get Best Tuning Parameters\n  best_mtry <- model$bestTune$mtry\n  preds_best <- model$pred |> filter(mtry == best_mtry)\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(preds_best$pred, preds_best$obs, positive = \"yes\")\n  \n  # Store Metrics\n  theta_model_metrics <- bind_rows(theta_model_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"thetas_only\"\n  ))\n}\n```\n:::\n\n\n\nIn the event that $\\theta$ values alone aren't sufficient, maybe it's possible that adding a binary indicator for string matches *alongside* $\\theta$ values as predictors in a machine learning algorithm aids in predictive accuracy, so I'm going to give that a shot as well.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add String Matches to Theta Data Frame\nslda_theta <- slda_theta |> \n  mutate(\n    grass_match = if_else(str_detect(info, str_c(grass_keys, collapse = \"|\")), 1, 0),\n    fire_match = if_else(str_detect(info, str_c(fire_keys, collapse = \"|\")), 1, 0),\n    water_match = if_else(str_detect(info, str_c(water_keys, collapse = \"|\")), 1, 0),\n    normal_match = if_else(str_detect(info, str_c(normal_keys, collapse = \"|\")), 1, 0),\n    electric_match = if_else(str_detect(info, str_c(electric_keys, collapse = \"|\")), 1, 0),\n    ice_match = if_else(str_detect(info, str_c(ice_keys, collapse = \"|\")), 1, 0),\n    fighting_match = if_else(str_detect(info, str_c(fighting_keys, collapse = \"|\")), 1, 0),\n    poison_match = if_else(str_detect(info, str_c(poison_keys, collapse = \"|\")), 1, 0),\n    ground_match = if_else(str_detect(info, str_c(ground_keys, collapse = \"|\")), 1, 0),\n    flying_match = if_else(str_detect(info, str_c(flying_keys, collapse = \"|\")), 1, 0),\n    psychic_match = if_else(str_detect(info, str_c(psychic_keys, collapse = \"|\")), 1, 0),\n    bug_match = if_else(str_detect(info, str_c(bug_keys, collapse = \"|\")), 1, 0),\n    rock_match = if_else(str_detect(info, str_c(rock_keys, collapse = \"|\")), 1, 0),\n    ghost_match = if_else(str_detect(info, str_c(ghost_keys, collapse = \"|\")), 1, 0),\n    dragon_match = if_else(str_detect(info, str_c(dragon_keys, collapse = \"|\")), 1, 0),\n    dark_match = if_else(str_detect(info, str_c(dark_keys, collapse = \"|\")), 1, 0),\n    steel_match = if_else(str_detect(info, str_c(steel_keys, collapse = \"|\")), 1, 0),\n    fairy_match = if_else(str_detect(info, str_c(fairy_keys, collapse = \"|\")), 1, 0)\n  )\n\n# Train Models\ngrass_model_thetas_sm <- train(type_grass ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + grass_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfire_model_thetas_sm <- train(type_fire ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fire_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nwater_model_thetas_sm <- train(type_water ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + water_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nnormal_model_thetas_sm <- train(type_normal ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + normal_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nelectric_model_thetas_sm <- train(type_electric ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + electric_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nice_model_thetas_sm <- train(type_ice ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ice_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfighting_model_thetas_sm <- train(type_fighting ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fighting_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npoison_model_thetas_sm <- train(type_poison ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + poison_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nground_model_thetas_sm <- train(type_ground ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ground_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nflying_model_thetas_sm <- train(type_flying ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + flying_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npsychic_model_thetas_sm <- train(type_psychic ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + psychic_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nbug_model_thetas_sm <- train(type_bug ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + bug_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nrock_model_thetas_sm <- train(type_rock ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + rock_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nghost_model_thetas_sm <- train(type_ghost ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ghost_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndragon_model_thetas_sm <- train(type_dragon ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + dragon_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndark_model_thetas_sm <- train(type_dark ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + dark_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nsteel_model_thetas_sm <- train(type_steel ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + steel_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfairy_model_thetas_sm <- train(type_fairy ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fairy_match, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\n\n# Store Models in a List\nmodel_list_thetas_sm <- list(\n  grass = grass_model_thetas_sm,\n  fire = fire_model_thetas_sm,\n  water = water_model_thetas_sm,\n  normal = normal_model_thetas_sm,\n  electric = electric_model_thetas_sm,\n  ice = ice_model_thetas_sm,\n  fighting = fighting_model_thetas_sm,\n  poison = poison_model_thetas_sm,\n  ground = ground_model_thetas_sm,\n  flying = flying_model_thetas_sm,\n  psychic = psychic_model_thetas_sm,\n  bug = bug_model_thetas_sm,\n  rock = rock_model_thetas_sm,\n  ghost = ghost_model_thetas_sm,\n  dragon = dragon_model_thetas_sm,\n  dark = dark_model_thetas_sm,\n  steel = steel_model_thetas_sm,\n  fairy = fairy_model_thetas_sm\n)\n\n# Create an Empty Data Frame to Store Results\ntheta_sm_model_metrics <- data.frame() \n\n# Loop Through Each Model\nfor (type in names(model_list_thetas_sm)) {\n  \n  model <- model_list_thetas_sm[[type]]\n  \n  # Get Best Tuning Parameters\n  best_mtry <- model$bestTune$mtry\n  preds_best <- model$pred |> filter(mtry == best_mtry)\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(preds_best$pred, preds_best$obs, positive = \"yes\")\n  \n  # Extract Metrics\n  theta_sm_model_metrics <- bind_rows(theta_sm_model_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"thetas_and_string_matching\"\n  ))\n}\n```\n:::\n\n\n\nLastly, maybe predictions can be enhanced if, alongside $\\theta$ values and string matching dummies, we include Pokemon statistics as predictors (HP, attack, defense, speed, etc.). Speed is heavily associated with types like electric, flying, rock, and steel. Types like psychic, electric, and ghost tend to have higher special attack statistics. So maybe including these as predictors could be helpful.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train Models\ngrass_model_thetas_sm_stats <- train(type_grass ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + grass_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfire_model_thetas_sm_stats <- train(type_fire ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fire_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nwater_model_thetas_sm_stats <- train(type_water ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + water_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nnormal_model_thetas_sm_stats <- train(type_normal ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + normal_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nelectric_model_thetas_sm_stats <- train(type_electric ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + electric_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nice_model_thetas_sm_stats <- train(type_ice ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ice_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfighting_model_thetas_sm_stats <- train(type_fighting ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fighting_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npoison_model_thetas_sm_stats <- train(type_poison ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + poison_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nground_model_thetas_sm_stats <- train(type_ground ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ground_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nflying_model_thetas_sm_stats <- train(type_flying ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + flying_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\npsychic_model_thetas_sm_stats <- train(type_psychic ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + psychic_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nbug_model_thetas_sm_stats <- train(type_bug ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + bug_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nrock_model_thetas_sm_stats <- train(type_rock ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + rock_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nghost_model_thetas_sm_stats <- train(type_ghost ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + ghost_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndragon_model_thetas_sm_stats <- train(type_dragon ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + dragon_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\ndark_model_thetas_sm_stats <- train(type_dark ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + dark_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nsteel_model_thetas_sm_stats <- train(type_steel ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + steel_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\nfairy_model_thetas_sm_stats <- train(type_fairy ~ grass + fire + water + electric + normal + ice + fighting + poison + ground + flying + psychic + bug + rock + ghost + dragon + dark + steel + fairy + fairy_match + hp + attack + defense + s_attack + s_defense + speed, data = slda_theta, method = \"rf\", metric = \"ROC\", trControl = cv)\n\n# Store Models in a List\nmodel_list_thetas_sm_stats <- list(\n  grass = grass_model_thetas_sm_stats,\n  fire = fire_model_thetas_sm_stats,\n  water = water_model_thetas_sm_stats,\n  normal = normal_model_thetas_sm_stats,\n  electric = electric_model_thetas_sm_stats,\n  ice = ice_model_thetas_sm_stats,\n  fighting = fighting_model_thetas_sm_stats,\n  poison = poison_model_thetas_sm_stats,\n  ground = ground_model_thetas_sm_stats,\n  flying = flying_model_thetas_sm_stats,\n  psychic = psychic_model_thetas_sm_stats,\n  bug = bug_model_thetas_sm_stats,\n  rock = rock_model_thetas_sm_stats,\n  ghost = ghost_model_thetas_sm_stats,\n  dragon = dragon_model_thetas_sm_stats,\n  dark = dark_model_thetas_sm_stats,\n  steel = steel_model_thetas_sm_stats,\n  fairy = fairy_model_thetas_sm_stats\n)\n\n# Create an Empty Data Frame to Store Results\ntheta_sm_stats_model_metrics <- data.frame()\n\n# Loop Through Each Model\nfor (type in names(model_list_thetas_sm_stats)) {\n  \n  model <- model_list_thetas_sm_stats[[type]]\n  \n  # Get Best Tuning Parameters\n  best_mtry <- model$bestTune$mtry\n  preds_best <- model$pred |> filter(mtry == best_mtry)\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(preds_best$pred, preds_best$obs, positive = \"yes\")\n  \n  # Extract metrics\n  theta_sm_stats_model_metrics <- bind_rows(theta_sm_stats_model_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"thetas_string_matching_and_stats\"\n  ))\n}\n```\n:::\n\n\n\nLastly, we arrive at the question of, \"should we even care about topic modeling at all?\". Why bother with all of this code when I can just give a spreadsheet and a prompt to ChatGPT and ask it predict Pokemon types based on their Pokedex entries? That's a fair enough point, so I tried that as well with Chat GPT-5 with the following prompt:\n\n> \"Please read this spreadsheet. Each row is a Pokémon and contains its Pokédex entry. Based on the info column alone, predict up to 2 likely Pokémon types for each entry. Return a table in spreadsheet form. There should be 18 columns stored as a dummy for each type. Preface each type columns with \"llm\\_\" and then the type name.\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import the Spreadsheet Chat GPT Gave Me\nllm_pokemon <- read_excel(\"data/Pokemon_LLM_Types.xlsx\")\n\n# Merge with the Tidy Pokemon Data Set\nllm_pokemon <- full_join(llm_pokemon, tidy_pokemon, by = c(\"id\", \"name\", \"info\"))\n\n# Create an Empty Data Frame to Store Results\nllm_metrics <- data.frame()\n\n# Loop Through Each Type for Predictive Metrics\nfor (type in types) {\n  \n  match_col <- paste0(\"llm_\", type)\n  true_col <- paste0(\"type_\", type)\n  \n  true <- factor(ifelse(llm_pokemon[[true_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  predicted <- factor(ifelse(llm_pokemon[[match_col]] == 1, \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\n  \n  # Confusion Matrix\n  cm <- confusionMatrix(predicted, true, positive = \"yes\")\n  \n  # Store Metrics\n  llm_metrics <- bind_rows(llm_metrics, data.frame(\n    type = type,\n    sensitivity = cm$byClass[\"Sensitivity\"],\n    specificity = cm$byClass[\"Specificity\"],\n    predictors = \"LLM\"\n  ))\n}\n```\n:::\n\n\n\nNow, with all of these predictions and different strategies merged into a single data frame, let's see how they fared.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_metrics <- full_join(string_matching_metrics, theta_model_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(theta_sm_model_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(theta_sm_stats_model_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(theta_30_sm_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(theta_40_sm_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(theta_50_sm_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\")) |> \n  full_join(llm_metrics, by = c(\"type\", \"sensitivity\", \"specificity\", \"predictors\"))\n```\n:::\n\n\n\n# Results\n\nThe plot below shows the sensitivity (accurate positive predictions / total positives) for each strategy. Because each type is a separate classification task, the balance between positives and negatives (i.e. \"is grass type\" vs. \"is not grass type\") is heavily skewed towards negatives. In this context, by default, just about any approach you use will be pretty conservative and push predictions towards negatives. As a result, I'm more interested in whether any of my approaches can identify the type a Pokemon *is* rather than the type a Pokemon *is not*. Each strategy has 18 dots, one for each type.\n\nAnd, as you can see, yikes! It's not looking great. I'd arbitrarily feel alright is the dots were clustered in the 60-80% range, but we are not really observing that here. Furthermore, the methods that were the most technically \"complex\" by far perform the worst. All three strategies that relied on a machine learning algorithm really struggled to detect positive values. Now, part of this could be explained by a lack of technical complexity regarding these algorithms, but I find it interesting that they still perform so poorly. Likewise, the LLM-generated predictions also perform much worse than the simple classification rules that rely on strings or theta values. But again, similar to the ML-based predictions, the LLM-generated predictions could also be improved with more attention focused in the prompts being given.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nall_metrics$predictors <- factor(\n  all_metrics$predictors,\n  levels = c(\n    \"LLM\",\n    \"thetas_string_matching_and_stats\",\n    \"thetas_and_string_matching\",\n    \"thetas_only\",\n    \"SLDA_50\",\n    \"SLDA_40\",\n    \"SLDA_30\",\n    \"string_matching\"\n  )\n)\n\nggplot(all_metrics, aes(x = sensitivity, y = predictors, fill = predictors)) +\n  # Add Stacked Dots\n  stat_dots(\n        side = \"top\",\n        scale = 0.6,\n        dotsize = 1,\n        color = \"black\"\n    ) +\n  # Add the Distribution Overlay\n  stat_slab(\n        side = \"top\",\n        scale = 0.9,\n        alpha = 0.5\n    ) +\n  # Custom Colors and Labels\n  scale_fill_manual(\n        values = c(\n            \"string_matching\" = \"#6a040f\",\n            \"thetas_only\" = \"#dc2f02\",\n            \"thetas_and_string_matching\" = \"#dc2f02\",\n            \"thetas_string_matching_and_stats\" = \"#dc2f02\",\n            \"SLDA_30\" = \"#f48c06\",\n            \"SLDA_40\" = \"#f48c06\",\n            \"SLDA_50\" = \"#f48c06\",\n            \"LLM\" = \"#ffba08\"\n        ),\n        labels = c(\n            \"string_matching\" = \"String Matching\",\n            \"thetas_only\" = \"Thetas Only\\nas Predictors\",\n            \"thetas_and_string_matching\" = \"Thetas +\\nString Matching\\nas Predictors\",\n            \"thetas_string_matching_and_stats\" = \"Thetas +\\nString Matching +\\nPoke Stats as\\nPredictors\",\n            \"SLDA_30\" = \"30% Theta\\nClassification\\nRule\",\n            \"SLDA_40\" = \"40% Theta\\nClassification\\nRule\",\n            \"SLDA_50\" = \"50% Theta\\nClassification\\nRule\",\n            \"LLM\" = \"LLM Predictions\"\n        )\n    ) +\n    scale_y_discrete(\n        labels = c(\n            \"string_matching\" = \"String Matching\",\n            \"thetas_only\" = \"Thetas Only\\nas Predictors\",\n            \"thetas_and_string_matching\" = \"Thetas +\\nString Matching\\nas Predictors\",\n            \"thetas_string_matching_and_stats\" = \"Thetas +\\nString Matching +\\nPoke Stats as\\nPredictors\",\n            \"SLDA_30\" = \"30% Theta\\nClassification\\nRule\",\n            \"SLDA_40\" = \"40% Theta\\nClassification\\nRule\",\n            \"SLDA_50\" = \"50% Theta\\nClassification\\nRule\",\n            \"LLM\" = \"LLM Predictions\"\n        )\n    ) +\n    labs(\n        title = \"\",\n        x = \"Sensitivity (True Positive Rate)\",\n        y = \"\"\n    ) +\n  scale_x_continuous(limits = c(0, 0.8)) +\n    blog_theme() +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Predictive Performance of Different Strategies](index_files/figure-html/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n\n\nThe big takeaway here should not be that the simplest approach is always the best. I think it would be fair to make two inferences based on these results. First, a simple approach can actually perform quite well on its own. However, while the floor for predictive performance may be pretty high, the ceiling might not be as high as more technical approaches. This leads to the second point. If you want to use a more technically complex approach (machine learning) or LLMs, it likely will require a bit of up-front lift to ensure that it performs better than simpler classification strategies. This is probably especially true for this example where the text data that we have for each Pokemon is incredibly sparse. I personally don't think the results would look like if, for example, we had a page a piece for each Pokemon.\n\nNext, we can evaluate which types each approach was able to predict with higher or lower accuracy. And there's some neat stuff here. Regardless of the strategy used, some types are much more easy to classify than others. The most prominent examples are the ice, electric, and fire types. I'm not very surprised with this. Personally, while writing out the key terms/seeds, I had a much easier time thinking of these terms when dealing with the \"elemental\" and less abstract Pokemon types. We have tons of words that we use to describe things like electricity and fire and so it's easy to find a list of terms that are distinct for those types.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nall_metrics$predictors <- factor(\n  all_metrics$predictors,\n  levels = rev(c(\n    \"LLM\",\n    \"thetas_string_matching_and_stats\",\n    \"thetas_and_string_matching\",\n    \"thetas_only\",\n    \"SLDA_50\",\n    \"SLDA_40\",\n    \"SLDA_30\",\n    \"string_matching\"\n  ))\n)\n\nggplot(all_metrics, aes(x = predictors, y = sensitivity, color = type)) +\n  geom_jitter(width = 0.25, height = 0, size = 3, alpha = 0.8) +\n  labs(\n    title = \"\",\n    x = \"\",\n    y = \"Sensitivity\",\n    color = \"Type\"\n  ) + \n  scale_fill_manual(\n    labels = c(\n    \"string_matching\" = \"String Matching\",\n    \"thetas_only\" = \"Thetas Only\\nas Predictors\",\n    \"thetas_and_string_matching\" = \"Thetas +\\nString\\nMatching\\nas Predictors\",\n    \"thetas_string_matching_and_stats\" = \"Thetas +\\nString\\nMatching +\\nPoke Stats as\\nPredictors\",\n    \"SLDA_30\" = \"30% Theta\\nClassification\\nRule\",\n    \"SLDA_40\" = \"40% Theta\\nClassification\\nRule\",\n    \"SLDA_50\" = \"50% Theta\\nClassification\\nRule\",\n    \"LLM\" = \"LLM Predictions\"\n  )\n) +\nscale_x_discrete(\n  labels = c(\n    \"string_matching\" = \"String Matching\",\n    \"thetas_only\" = \"Thetas Only\\nas Predictors\",\n    \"thetas_and_string_matching\" = \"Thetas +\\nString\\nMatching\\nas Predictors\",\n    \"thetas_string_matching_and_stats\" = \"Thetas +\\nString\\nMatching +\\nPoke Stats as\\nPredictors\",\n    \"SLDA_30\" = \"30% Theta\\nClassification\\nRule\",\n    \"SLDA_40\" = \"40% Theta\\nClassification\\nRule\",\n    \"SLDA_50\" = \"50% Theta\\nClassification\\nRule\",\n    \"LLM\" = \"LLM Predictions\"\n  )\n) +\n  scale_color_manual(\n    values = type_colors,   \n    labels = type_names    \n  ) +\n  scale_y_continuous(limits = c(0, 0.8)) +\n  blog_theme()\n```\n\n::: {.cell-output-display}\n![Predictive Performance of Different Strategies by Pokemon Type](index_files/figure-html/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n\nBut what about the types that are much more abstract? Like fairy, dragon, and normal? As you can see, and as expected, a lot of the approaches used really struggled to classify these types correctly. After all, what makes a fairy-type Pokemon *fairy-type*? What about normal types? For normal types in particular, what really makes them *normal* is just the *absence* of any elemental or magical powers. A type being defined in *negative* terms is one that is really hard to classify, at least when solely using the information (Pokedex entries) for this analysis.\n\n# Conclusion\n\nOverall, can you reliably predict a Pokemon's type by using information from its Pokedex entries (and, in some cases, its statistics)? Not really. Or at least, not at a casual glance. Further, much like all other things data science-y, your results will only be as good as your data. Likewise, as your data worsens, either in scope or quality, \"simpler\" strategies are not always the least desired.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}